# design-docs

## 全体図

(To Be Documented: わかりやすく図解した画像ファイル)

## リモートサーバーから投稿が入ってきたとき

1. ブリッジサーバーからローカルサーバーあてにアクティビティペイロードが入ってくる
2. スパムフィルターを通す
3. 署名を検証する
4. ローカルサーバーに転送する
5. リモートアクターをGetOrFetchする
6. 当該アクティビティをDapeのエンティティに翻訳する
7. データベース層に書き込みを行う

### スパムフィルター
この時点では署名は検証していない。検証していないが、例えば明らかなスパムについては署名を検証する必要がないので弾ける。

善人がスパムを偽装する意味がないので、100%スパムであると断言できるものについてはここで捨てることができる。

ここで捨てると、署名が検証されないので多少CPUパワーを節約できる。
逆に言うと、真っ黒なものしか弾くべきではない。

### 署名検証
署名検証はed25519
## ストリームスライス

### ストリームスライスの定義

ここでいうストリームスライスとは、

1. 閲覧者がフォローしているユーザーの投稿
2. ユーザーリストに入れられているユーザーの投稿
3. (Misskey で言うところの) アンテナにマッチしたユーザーの投稿

を、それぞれ作成日時が新しい順から古い順に並べた連続部分列を指す。

要するに、各種SNSで「タイムライン」と言われて思い浮かべるものとおおよそ合致する。

ただし、Twitterや9ineverse、はなみすきーに存在するレコメンデーションベースの投稿アピアランスは慣例的に「タイムライン」と呼ばれているもののこの定義には含まれない。

そのようなレコメンデーションベースの投稿アピアランスは、ソートの順位が時系列にとどまらず異なった指標を用いて算出されるため、このセクションでは扱わない。

### 構築するとき

Redis の [SortedSet] を活用して [Fanout-timeline] を構築する

[SortedSet]: https://valkey.io/topics/sorted-sets/
[Fanout-timeline]: https://www.infoq.com/presentations/Twitter-Timeline-Scalability/

Aliceがノートした時、Aliceの各フォロワーのID`followee_id` に対して `timeline:home:{followee_id}` キーへ更新をかける \
→投稿時刻のUnixTimestampをスコア、投稿IDをキーとする`ZADD`コマンドを発行する

取得時は`ZREVRANGE`コマンドでとってくる

ログインユーザー1人につき、最新N件を持っておく (N <= 3000) \
→古くなったり溢れたりしたらキャッシュ削除でキャッシュがかさまないようにする

### データベースにフォールバックすることによって生まれるパフォーマンスのデグレを防ぐために意図的に導入する非正規化構造
#### タイムラインを構築するときの補助ノード
実際にデータベースにフォールバックが発生してもいいように、デイリーで投稿したユーザーを関連付けるノードを新しく作成する。例えば、`(d:DailyPost { date: "2024-05-01+0900" }) -[:CONTAINS] -> (u:User { id: "uid_example" })` というようなリレーションを挿入する。

#### lastPostedAt
これを持たせることで全ユーザー操作ではなく、インデックスを生かした操作になることが期待できる。また、統計的に最近ノートしたユーザーについてはよくノートするので、そういう状況も考えると有効な最適化だと思われる。

