# design-docs

## 全体図

(To Be Documented: わかりやすく図解した画像ファイル)

### リモートサーバーから投稿が入ってきたとき

1. ブリッジサーバーからローカルサーバーあてにアクティビティペイロードが入ってくる
2. スパムフィルターを通す
3. 署名を検証する
4. ローカルサーバーに転送する
5. リモートアクターをGetOrFetchする
6. 当該アクティビティをDapeのエンティティに翻訳する
7. データベース層に書き込みを行う

Cf Queueなどを活用してバッチ処理を行う予定 - 後でちゃんと書く

### タイムラインを構築するとき

Redis の SortedSet を活用して Fanout-timeline を構築する

(To Be Documented: どのようにして構築する？また、どのようにしたら実際にタイムラインとして最近投稿された順に並ぶ？)
(To Be Documented: DBにフォールバックする閾値は？)

### リスト・アンテナを構築するとき

同上

### タイムラインを構築するときにデータベースにフォールバックすることによって生まれるパフォーマンスのデグレを防ぐために意図的に導入する非正規化構造
#### タイムラインを構築するときの補助ノード
実際にデータベースにフォールバックが発生してもいいように、デイリーで投稿したユーザーを関連付けるノードを新しく作成する。例えば、`(d:DailyPost { date: "2024-05-01+0900" }) -[:CONTAINS] -> (u:User { id: "uid_example" })` というようなリレーションを挿入する。

#### lastPostedAt
これを持たせることで全ユーザー操作ではなく、インデックスを生かした操作になることが期待できる。また、統計的に最近ノートしたユーザーについてはよくノートするので、そういう状況も考えると有効な最適化だと思われる。

