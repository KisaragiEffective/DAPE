# コーディングガイドライン

DAPEにおけるコーディングガイドラインを定めます。

## 1. 原則

### 1.1. Microsoft が推奨するコーディングガイドラインをベースとして用いる

[Microsoft が推奨するコーディングガイドライン (英語)](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions) 及び
[命名ガイドライン (英語)](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/identifier-names) をベースとして用います。

### 1.2. ドキュメントよりも命名、命名よりもシグネチャ

メソッドやプロパティ、フィールドなどに書かれるドキュメントは往々にしてコードベースとの同期が遅れ、腐りやすいです。

そのため、ドキュメントに書く前に命名に反映できないか検討してください。また、命名に反映する前に、戻り値型、引数の型、属性によって表現できないか検討してください。

以下は、検討にあたって優先するべき順位で並べた指針です。

1. 引数の型・戻り値の型
2. 属性
3. 命名
4. コードと同じファイルに埋め込まれるドキュメント
5. コードと異なるファイルに置かれるドキュメント

## 2. 構文的な規則

### var はどこでも使う

我々は統合開発環境を用いてコーディングをするため、`var` が使える箇所ではどこでも `var` を使用します。

### `private` フィールド・プロパティ以外で型名を省略したコンストラクタの呼び出しを行わない

型名を省略したコンストラクタの呼び出しを行わないでください。

違反例:

```cs
Meter meter = new();
```

修正例:

```cs
var meter = new Meter();
```

例外: `private` フィールド及びプロパティを除きます。

```cs
public class Foo {
    private Meter _meter = new();
}
```

### `static` フィールド・プロパティに `s_` を前置しない

`static` なフィールド・プロパティに `s_` を前置しないでください。

### C# の予約語と同じ命名は避ける

C# の予約語と同じ命名は避けてください。raw identifier escape を用いても同様です。

理由: `@` がタイピングしにくいため。

### System.Attribute のサブクラスの命名の末尾に `Attribute` をつけない

.

### スコープの長さに応じて説明度が高い名前をつける

スコープの長さに応じて説明度が高い名前をつけるようにしてください。

スコープの長さは、以下の順で長いものとします。

* アクセス修飾子が緩ければ緩いほど長くなる
* `readonly` 

## Appendix A. 細則

### A.1. コードと異なるファイルに置かれるドキュメントには、高次のドキュメントのみ置く

コードと異なるファイルに置かれるドキュメントについては、高次のドキュメントのみ置くようにしてください。

「高次のドキュメント」とは、以下のような個々のファイルをまたぐ大きいスコープに対するドキュメントです。

* README.md (DAPE の紹介、インストール方法、……)
* CONTRIBUTING.md (DAPE に貢献する方法の紹介)
* LICENSE.md (DAPE の利用が許可される範囲)
* CODING_GUIDELINE.md (DAPE のコードを統制するガイドライン)
* ARCHITECTURE.md (DAPE の設計の解説)

### A.2. 複数通りの解釈をできるユーザー定義演算子を定義しない

`TimeSpan.operator+(int) -> TimeSpan` などの命名を見ないとどのような動作をするか不明瞭なユーザー定義演算子は定義するべきではありません。

改善案:

1. 明示的なメソッドにし、適切な名前を与える。例えば、`TimeSpan.AddMinutes(int) -> TimeSpan` は意図が明確です。
2. シグネチャを変更し、適切な意味論が明確になるようにする。例えば、 `TimeSpan.AddMinutes(Minute) -> TimeSpan` は意図が明確です。

この規則に当てはまらないケース:

* `Meter.operator*(int) -> Meter` はメートルのスカラー倍なので、このケースには当てはまりません。
* `Meter.operator/(Meter) -> double` はメートル同士の比を求めているので、このケースには当てはまりません。
* `Meter.operator+(Meter) -> Meter` はメートル同士の加算なので、このケースには当てはまりません。
* `Meter.operator-(Meter) -> Meter` はメートル同士の減算なので、このケースには当てはまりません。

### A.3. var はどこでも使う
