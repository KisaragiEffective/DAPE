# コーディングガイドライン

DAPEにおけるコーディングガイドラインを定めます。

## 原則

### Microsoft が推奨するコーディングガイドラインをベースとして用いる

[Microsoft が推奨するコーディングガイドライン (英語)](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions)
及び
[命名ガイドライン (英語)](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/identifier-names)
をベースとして用います。

### ドキュメントよりも命名、命名よりもシグネチャ

メソッドやプロパティ、フィールドなどに書かれるドキュメントは往々にしてコードベースとの同期が遅れ、腐りやすいです。

そのため、ドキュメントに書く前に命名に反映できないか検討してください。また、命名に反映する前に、戻り値型、引数の型、属性によって表現できないか検討してください。

以下は、検討にあたって優先するべき順位で並べた指針です。

1. 引数の型・戻り値の型
2. 属性
3. 命名
4. コードと同じファイルに埋め込まれるドキュメント
5. コードと異なるファイルに置かれるドキュメント

## 構文的な規則

### `var` はどこでも使う

我々は統合開発環境を用いてコーディングをするため、`var` が使える箇所ではどこでも `var` を使用します。

### `private` フィールド・プロパティ以外で型名を省略したコンストラクタの呼び出しを行わない

型名を省略したコンストラクタの呼び出しを行わないでください。

違反例:

```cs
Meter meter = new();
```

修正例:

```cs
var meter = new Meter();
```

例外: `private` フィールド及びプロパティを除きます。

```cs
public class Foo {
    private Meter _meter = new();
}
```

### 非同期メソッド名の末尾には `Async` を付ける

`Task` または `Task<T>` を返すメソッドには、末尾に `Async` を付けてください。

例外: 明確に非同期であると分かる文脈（例: `IAsyncOperation.Execute()`）では `Async` を省略してもかまいません。

理由: メソッドの使用箇所から非同期性が一目で分かるようにするためです。

### `static` フィールド・プロパティに `s_` を前置しない

`static` なフィールド・プロパティに `s_` を前置しないでください。

### C# の予約語と同じ命名は避ける

C# の予約語と同じ命名は避けてください。raw identifier escape を用いても同様です。

理由: `@` がタイピングしにくいため。

### System.Attribute のサブクラスの命名の末尾に `Attribute` をつけない

冗長

### スコープの長さに応じて説明度が高い名前をつける

スコープが広いほど、変数やメソッドなどの名前はより説明的で意味が明確なものにしてください。逆に、スコープが極めて限定的（例:
for ループ内など）であれば、簡潔な名前を使用してもかまいません。

スコープが広くなると、変数の使用場所と定義場所が離れるため、短い・曖昧な名前では意味が把握しづらくなります。

以下のような観点からスコープの長さを推定し、名前の説明度を調整してください。

| 属性         | 	スコープが長くなる傾向の方向                          |
|:-----------|:-----------------------------------------|
| アクセス修飾子    | 	private → protected → internal → public |
| `readonly` | 	ない方がスコープが長い（状態変化が起き得るため）                |
| `static`	  | ある方がスコープが長い（インスタンスに依存しないため共有範囲が広い）       |
| `sealed`	  | ない方がスコープが長い（継承先で使われる可能性がある）              |
| `virtual`  | 	ある方がスコープが長い（オーバーライドされ得るため多様な場所で使用されうる）  |

命名例:

| スコープ               | 	命名例                                  | 	解説                           |
|:-------------------|:--------------------------------------|:------------------------------|
| ローカル変数（for文内）      | 	`i`, `temp`                          | 	数行以内で完結する用途なら簡潔に             |
| メソッド内で再利用されるローカル変数 | 	`userName`, `isRetryEnabled`	        | 意味を明確に                        |
| private フィールド      | 	`_lastLoginTime`                     | 	クラス全体で使われるため説明的に             |
| public プロパティ       | 	`UserDisplayName`, `IsAdministrator` | 	外部 API の一部として読みやすく、意図が伝わる名前に |

悪い例:

```cs
private int x; // 何の数値か分からない
```

良い例:

```cs
private int retryCount;
```

備考:

この指針は変数・フィールド・プロパティ・メソッドなどすべてに適用されます。**「外に見せるものほど自己説明的であるべき」**
という原則を忘れないでください。

### `Utility` またはそれに類する名前をクラス名に入れない

以下の部分文字列は、*神クラス* を招きやすいため、クラス名の一部として利用しないでください。

* `Utility`
* `Util`

## 意味論的な規則

### コードと異なるファイルに置かれるドキュメントには、高次のドキュメントのみ置く

コードと異なるファイルに置かれるドキュメントについては、高次のドキュメントのみ置くようにしてください。

「高次のドキュメント」とは、以下のような個々のファイルをまたぐ大きいスコープに対するドキュメントです。

* ARCHITECTURE.md (DAPE の設計の解説)
* CODING_GUIDELINE.md (DAPE のコードを統制するガイドライン)
* CONTRIBUTING.md (DAPE に貢献する方法の紹介)
* FAQ.md (DAPE のよくある質問)
* LICENSE.md (DAPE の利用が許可される範囲)
* README.md (DAPE の紹介、インストール方法、……)

### 複数通りの解釈を生むユーザー定義演算子を避ける

`TimeSpan.operator+(int) -> TimeSpan` のように、演算子のシグネチャや名前から動作の意図が明確にわからないユーザー定義演算子は定義しないでください。

#### 推奨される代替手段

1. 明示的なメソッドを定義し、動作が一目でわかる名前を付ける。  
   例: `TimeSpan.AddMinutes(int) -> TimeSpan`
2. 引数の型を具体化し、意味を明確にする。  
   例: `TimeSpan.operator+(Minute) -> TimeSpan`

#### 例外ケース（適用しない例）

- `Meter.operator*(int) -> Meter` （スカラー倍で意味が明確）
- `Meter.operator/(Meter) -> double` （比率計算で意味が明確）
- `Meter.operator+(Meter) -> Meter` （加算で意味が明確）
- `Meter.operator-(Meter) -> Meter` （減算で意味が明確）

### `partial` の使用はコード生成および責務分離に限定する

`partial` キーワードを使用してクラスや構造体を定義する場合は、以下のような目的に限定してください。

- 自動生成されたコードと手書きコードの分離（例: `*.g.cs` ファイル）
- 単一クラスに複数の責務（ビューとロジックなど）を明示的に分割する場合

上記以外の理由による `partial` の使用は避けてください。

### 匿名型およびタプルの使用はスコープを限定し、要素名を説明的にする

匿名型 (`new { ... }`) や `ValueTuple` (`(int x, int y)`) を使用する場合は、以下を守ってください。

- 使うスコープを限定的（メソッド内）にとどめる
- 要素名は必ず意味のあるものにする
- メソッドの戻り値やフィールドとしては使用しない（型情報が失われるため）

悪い例:

```cs
return (1, 2);
```

良い例:

```cs
return (rowCount: 1, columnCount: 2);
```

### 独自の例外型には `Exception` を末尾に付け、スロー条件を明確にする

独自の例外型を定義する場合は、`System.Exception` またはそのサブクラスを継承し、型名の末尾に `Exception` を付けてください。

- `InvalidConfigurationException`
- `DataAccessException`

また、例外をスローする際には、その条件をドキュメントまたはコードコメントで明示してください。

```cs
/// Throws when the user is not found in the database.
throw new UserNotFoundException(userId);
```

例外を返すのではなく、投げる（throw）ことを前提としてください。

### nullable reference types をすべてのアセンブリで使う

すべてのアセンブリで #nullable enable を有効とし、nullable reference types に対応したコードのみを記述してください。

* string? など、null 許容型を意図的に使う場合は、null になる可能性とその取り扱いについてコメントで明記することが望ましいです。
* 逆に、nullable reference types を明示していない状態（#nullable disable）は使用禁止とします。

### 否定形のプロパティ命名について

* IsDisabled のような否定形の命名は、一般的に可読性が落ちるため避け、前向きな命名（例: IsEnabled）を推奨します。
* ただし、肯定形プロパティのみの場合、両方用意すると冗長になるため否定形を追加しないことは許容します。
* 否定形プロパティが存在しない場合でも、if (!x) のような否定条件は特別に許容し、読みやすさを優先します。

## 4. 用語の定義

### "Shared Kernel" という用語は用いない

代わりに、すべてのモジュールに共通する基礎として *Base レイヤー* という単語を用います。
