# ストリームスライス

## ストリームスライスの定義

ここでいうストリームスライスとは、

1. 閲覧者がフォローしているユーザーの投稿
2. ユーザーリストに入れられているユーザーの投稿
3. (Misskey で言うところの) アンテナにマッチしたユーザーの投稿

を、それぞれ作成日時が新しい順から古い順に並べた連続部分列を指す。

要するに、各種SNSで「タイムライン」と言われて思い浮かべるものとおおよそ合致する。

ただし、Twitterやはなみすきーに存在するレコメンデーションベースの投稿アピアランスは慣例的に「タイムライン」と呼ばれているもののこの定義には含まれない。

そのようなレコメンデーションベースの投稿アピアランスは、ソートの順位が時系列にとどまらず異なった指標を用いて算出されるため、このセクションでは扱わない。

## ストリームスライスの構築

インメモリストアにFIFOなID列を蓄積する。

具体的にはRedis の [SortedSet] を活用して [Fanout-timeline] を構築する。

[SortedSet]: https://valkey.io/topics/sorted-sets/
[Fanout-timeline]: https://www.infoq.com/presentations/Twitter-Timeline-Scalability/

Aliceがノートした時、Aliceの各フォロワーのID`followee_id` に対して `timeline:home:{followee_id}` キーへ更新をかける \
→投稿時刻のUnixTimestampをスコア、投稿IDをキーとする`ZADD`コマンドを発行する

取得時は`ZREVRANGE`コマンドでとってくる

ログインユーザー1人につき、最新N件を持っておく (N <= 3000) \
→古くなったり溢れたりしたらキャッシュ削除でキャッシュがかさまないようにする \
→`ZREMRANGE` コマンドを発行し、常に1ユーザーあたりのストリームスライスの件数を一定以下に抑える。

## データベースフォールバック時の対策

ストリームスライスキャッシュにヒットしなかった時、データベースにフォールバックする。
しかし、データベースにフォールバックすると1桁遅くなるので、できるだけパフォーマンスに影響が出ないように対策を打ちたい。

### Post ノードの created_at フィールドにインデックスを張る

```cypher
CREATE RANGE INDEX idx_note_created_at IF NOT EXISTS
FOR (e:Post) ON (e.createdAt)
```

#### lastPostedAt
これを持たせることで全ユーザー操作ではなく、インデックスを生かした操作になることが期待できる。

また、統計的に最近ノートしたユーザーについてはよくノートするので、そういう状況も考えると有効な最適化だと思われる。

```cypher
CREATE RANGE INDEX idx_user_last_posted_at IF NOT EXISTS
FOR (e:User) ON (e.lastPostedAt)
```

#### キャッシュミスをしても補填

キャッシュにヒットしなかった時、データベースにフォールバックする。

しかし、常にフォールバックしっぱなしだとCPU資源的には良くない。

そこで、データベースにフォールバックした時点でネットワークを参照してストリームスライスのキャッシュを
構築するジョブをバックグラウンドで走らせる。

#### インメモリストアは適切なタイミングでコミットする

インメモリストアはサーバー終了前に永続ファイルへ書き出す。

また、サーバー始動前に永続ファイルを読み込んでインメモリストアに展開し直す。

サーバーが死んでいる場合、基本的に永続ファイルのステートは実状態と一貫性が保たれる。

TODO: メンテナンスなどで一時的にダウンさせていた場合、実状態との不整合が生じる。そのケースはどうやってカバーする？
